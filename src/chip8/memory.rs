pub struct Memory {
  memory: [u8; 0xFFF], //4095 positions
}

impl Memory {
  pub fn new(instructions: Vec<u8>) -> Memory {
    // 0x000 to 0x1FF Reserved for interpreter
    if instructions.len() > (0xFFF - (0x1FF)) {
      panic!("Max instructions length is 3583");
    }

    let mut memory = [0; 0xFFF];

    Memory::load_predefined_instructions(&mut memory);

    for (index, instruction) in instructions.iter().enumerate() {
      memory[index + 0x200] = *instruction;
    }

    Memory { memory }
  }

  fn load_predefined_instructions(memory: &mut [u8; 0xFFF]) {
    let sprites: [[u8; 5]; 16] = [
      [0xF0, 0x90, 0x90, 0x90, 0xF0],
      [0x20, 0x60, 0x20, 0x20, 0x70],
      [0xF0, 0x10, 0xF0, 0x80, 0xF0],
      [0xF0, 0x10, 0xF0, 0x10, 0xF0],
      [0x90, 0x90, 0xF0, 0x10, 0x10],
      [0xF0, 0x80, 0xF0, 0x10, 0xF0],
      [0xF0, 0x80, 0xF0, 0x90, 0xF0],
      [0xF0, 0x10, 0x20, 0x40, 0x40],
      [0xF0, 0x90, 0xF0, 0x90, 0xF0],
      [0xF0, 0x90, 0xF0, 0x10, 0xF0],
      [0xF0, 0x90, 0xF0, 0x90, 0x90],
      [0xE0, 0x90, 0xE0, 0x90, 0xE0],
      [0xF0, 0x80, 0x80, 0x80, 0xF0],
      [0xE0, 0x90, 0x90, 0x90, 0xE0],
      [0xF0, 0x80, 0xF0, 0x80, 0xF0],
      [0xF0, 0x80, 0xF0, 0x80, 0x80],
    ];

    let mut i = 0;
    for sprite in &sprites {
      for &ch in sprite {
        memory[i] = ch;
        i += 1;
      }
    }
  }
}
